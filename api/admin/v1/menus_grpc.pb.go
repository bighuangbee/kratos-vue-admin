// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: menus.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Menus_CreateMenus_FullMethodName        = "/api.admin.v1.Menus/CreateMenus"
	Menus_ListMenus_FullMethodName          = "/api.admin.v1.Menus/ListMenus"
	Menus_GetMenusTree_FullMethodName       = "/api.admin.v1.Menus/GetMenusTree"
	Menus_UpdateMenus_FullMethodName        = "/api.admin.v1.Menus/UpdateMenus"
	Menus_DeleteMenus_FullMethodName        = "/api.admin.v1.Menus/DeleteMenus"
	Menus_GetMenus_FullMethodName           = "/api.admin.v1.Menus/GetMenus"
	Menus_RoleMenuTreeSelect_FullMethodName = "/api.admin.v1.Menus/RoleMenuTreeSelect"
)

// MenusClient is the client API for Menus service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenusClient interface {
	// 创建菜单
	CreateMenus(ctx context.Context, in *CreateMenusRequest, opts ...grpc.CallOption) (*CreateMenusReply, error)
	// 菜单列表
	ListMenus(ctx context.Context, in *ListMenusRequest, opts ...grpc.CallOption) (*ListMenusReply, error)
	// 获取菜单关系结构
	GetMenusTree(ctx context.Context, in *GetMenusTreeRequest, opts ...grpc.CallOption) (*GetMenusTreeReply, error)
	// 更新菜单
	UpdateMenus(ctx context.Context, in *UpdateMenusRequest, opts ...grpc.CallOption) (*UpdateMenusReply, error)
	// 删除菜单
	DeleteMenus(ctx context.Context, in *DeleteMenusRequest, opts ...grpc.CallOption) (*DeleteMenusReply, error)
	// 获取菜单
	GetMenus(ctx context.Context, in *GetMenusRequest, opts ...grpc.CallOption) (*GetMenusReply, error)
	// 获取角色菜单树
	RoleMenuTreeSelect(ctx context.Context, in *RoleMenuTreeSelectRequest, opts ...grpc.CallOption) (*RoleMenuTreeSelectReply, error)
}

type menusClient struct {
	cc grpc.ClientConnInterface
}

func NewMenusClient(cc grpc.ClientConnInterface) MenusClient {
	return &menusClient{cc}
}

func (c *menusClient) CreateMenus(ctx context.Context, in *CreateMenusRequest, opts ...grpc.CallOption) (*CreateMenusReply, error) {
	out := new(CreateMenusReply)
	err := c.cc.Invoke(ctx, Menus_CreateMenus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menusClient) ListMenus(ctx context.Context, in *ListMenusRequest, opts ...grpc.CallOption) (*ListMenusReply, error) {
	out := new(ListMenusReply)
	err := c.cc.Invoke(ctx, Menus_ListMenus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menusClient) GetMenusTree(ctx context.Context, in *GetMenusTreeRequest, opts ...grpc.CallOption) (*GetMenusTreeReply, error) {
	out := new(GetMenusTreeReply)
	err := c.cc.Invoke(ctx, Menus_GetMenusTree_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menusClient) UpdateMenus(ctx context.Context, in *UpdateMenusRequest, opts ...grpc.CallOption) (*UpdateMenusReply, error) {
	out := new(UpdateMenusReply)
	err := c.cc.Invoke(ctx, Menus_UpdateMenus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menusClient) DeleteMenus(ctx context.Context, in *DeleteMenusRequest, opts ...grpc.CallOption) (*DeleteMenusReply, error) {
	out := new(DeleteMenusReply)
	err := c.cc.Invoke(ctx, Menus_DeleteMenus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menusClient) GetMenus(ctx context.Context, in *GetMenusRequest, opts ...grpc.CallOption) (*GetMenusReply, error) {
	out := new(GetMenusReply)
	err := c.cc.Invoke(ctx, Menus_GetMenus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menusClient) RoleMenuTreeSelect(ctx context.Context, in *RoleMenuTreeSelectRequest, opts ...grpc.CallOption) (*RoleMenuTreeSelectReply, error) {
	out := new(RoleMenuTreeSelectReply)
	err := c.cc.Invoke(ctx, Menus_RoleMenuTreeSelect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenusServer is the server API for Menus service.
// All implementations must embed UnimplementedMenusServer
// for forward compatibility
type MenusServer interface {
	// 创建菜单
	CreateMenus(context.Context, *CreateMenusRequest) (*CreateMenusReply, error)
	// 菜单列表
	ListMenus(context.Context, *ListMenusRequest) (*ListMenusReply, error)
	// 获取菜单关系结构
	GetMenusTree(context.Context, *GetMenusTreeRequest) (*GetMenusTreeReply, error)
	// 更新菜单
	UpdateMenus(context.Context, *UpdateMenusRequest) (*UpdateMenusReply, error)
	// 删除菜单
	DeleteMenus(context.Context, *DeleteMenusRequest) (*DeleteMenusReply, error)
	// 获取菜单
	GetMenus(context.Context, *GetMenusRequest) (*GetMenusReply, error)
	// 获取角色菜单树
	RoleMenuTreeSelect(context.Context, *RoleMenuTreeSelectRequest) (*RoleMenuTreeSelectReply, error)
	mustEmbedUnimplementedMenusServer()
}

// UnimplementedMenusServer must be embedded to have forward compatible implementations.
type UnimplementedMenusServer struct {
}

func (UnimplementedMenusServer) CreateMenus(context.Context, *CreateMenusRequest) (*CreateMenusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMenus not implemented")
}
func (UnimplementedMenusServer) ListMenus(context.Context, *ListMenusRequest) (*ListMenusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMenus not implemented")
}
func (UnimplementedMenusServer) GetMenusTree(context.Context, *GetMenusTreeRequest) (*GetMenusTreeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenusTree not implemented")
}
func (UnimplementedMenusServer) UpdateMenus(context.Context, *UpdateMenusRequest) (*UpdateMenusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenus not implemented")
}
func (UnimplementedMenusServer) DeleteMenus(context.Context, *DeleteMenusRequest) (*DeleteMenusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenus not implemented")
}
func (UnimplementedMenusServer) GetMenus(context.Context, *GetMenusRequest) (*GetMenusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenus not implemented")
}
func (UnimplementedMenusServer) RoleMenuTreeSelect(context.Context, *RoleMenuTreeSelectRequest) (*RoleMenuTreeSelectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuTreeSelect not implemented")
}
func (UnimplementedMenusServer) mustEmbedUnimplementedMenusServer() {}

// UnsafeMenusServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenusServer will
// result in compilation errors.
type UnsafeMenusServer interface {
	mustEmbedUnimplementedMenusServer()
}

func RegisterMenusServer(s grpc.ServiceRegistrar, srv MenusServer) {
	s.RegisterService(&Menus_ServiceDesc, srv)
}

func _Menus_CreateMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMenusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenusServer).CreateMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menus_CreateMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenusServer).CreateMenus(ctx, req.(*CreateMenusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menus_ListMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMenusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenusServer).ListMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menus_ListMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenusServer).ListMenus(ctx, req.(*ListMenusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menus_GetMenusTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenusTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenusServer).GetMenusTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menus_GetMenusTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenusServer).GetMenusTree(ctx, req.(*GetMenusTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menus_UpdateMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMenusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenusServer).UpdateMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menus_UpdateMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenusServer).UpdateMenus(ctx, req.(*UpdateMenusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menus_DeleteMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMenusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenusServer).DeleteMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menus_DeleteMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenusServer).DeleteMenus(ctx, req.(*DeleteMenusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menus_GetMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenusServer).GetMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menus_GetMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenusServer).GetMenus(ctx, req.(*GetMenusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menus_RoleMenuTreeSelect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuTreeSelectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenusServer).RoleMenuTreeSelect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menus_RoleMenuTreeSelect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenusServer).RoleMenuTreeSelect(ctx, req.(*RoleMenuTreeSelectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Menus_ServiceDesc is the grpc.ServiceDesc for Menus service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Menus_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.admin.v1.Menus",
	HandlerType: (*MenusServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMenus",
			Handler:    _Menus_CreateMenus_Handler,
		},
		{
			MethodName: "ListMenus",
			Handler:    _Menus_ListMenus_Handler,
		},
		{
			MethodName: "GetMenusTree",
			Handler:    _Menus_GetMenusTree_Handler,
		},
		{
			MethodName: "UpdateMenus",
			Handler:    _Menus_UpdateMenus_Handler,
		},
		{
			MethodName: "DeleteMenus",
			Handler:    _Menus_DeleteMenus_Handler,
		},
		{
			MethodName: "GetMenus",
			Handler:    _Menus_GetMenus_Handler,
		},
		{
			MethodName: "RoleMenuTreeSelect",
			Handler:    _Menus_RoleMenuTreeSelect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "menus.proto",
}
